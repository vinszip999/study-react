<!-- 배열(리스트) 다루기 -->
<script>
    let lst = [
        { id: 1, name: "John" },
        { id: 2, name: "Jane" },
        { id: 3, name: "Paul" },
    ]
    // lst.push({ id: 4, name: "Ken" })
    // console.log(lst)

    // 요소 추가는 concat 메소드를 이용하여 처리
    let newLst = lst.concat({ id: 4, name: "Ken" })
    console.log("concat =====")
    console.log(lst) // 원본에 영향 주지 않음 (변화가 없음)
    console.log(newLst) // 새로운 리스트 객체가 생성됨 (Ken 추가)
    console.log(lst === newLst) // 서로 다른 객체이므로 false를 반환

    // 요소 내용 변경은 map 메소드를 이용하여 처리
    let updatedId = 2
    let updatedName = "Smith"
    let updatedLst = lst.map(item => {
        if (item.id === updatedId) {
            // 다음과 같이 객체를 직접 변경하지 않고 (원본 리스트는 불변!)
            item.name = updatedName

            // 전개 연산자를 이용하여 값 복사 후 덮어쓰기 전략으로 새 객체를 생성하여 대입하기
            return { ...item, name: updatedName }
        }
        return item
    })
    console.log(updatedLst)

    // 요소 삭제는 filter 메소드를 이용하여 처리
    let removeId = 1
    let removeLst = lst.filter(item => {
        return item.id !== removeId
    })
    console.log("filter =====")
    console.log(lst) // 원본에 영향 X
    console.log(removedLst) // 새로운 객체
    console.log(lst === removedLst) // false

    // map 메소드 설명
    let arr = [1, 2, 3]
    let ret1 = arr.map(v => v * 2)
    let ret2 = arr.map(function (v) {
        return (v % 2) == 0 // 짝수를 구하는 것이기 때문에 false, true, false, true 반환
    })

    // filter 메소드 설명
    let f1 = arr.filter(v => v > 2)
    let f2 = arr.filter(v => (v % 2) == 0)

</script>